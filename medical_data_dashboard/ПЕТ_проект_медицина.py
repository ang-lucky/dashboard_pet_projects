#!/usr/bin/env python
# coding: utf-8

# # Проект "Дашборд: медицинские данные злокачественных заболеваний за 2021 г"

# ## Импорт библиотек 

# In[1]:


import pandas as pd
import re


# ## Изучение данных

# Были данны 6 таблиц: две общие таблицы по смертности и по заболеваемости и 4 разделенные на половые характеристики. Предварительно таблицы были изучены в excel. Все таблицы имеют одинаковый порядок колонок с одинаковыми названиями с совпадающим их количеством. Откроем одну из таблиц. 

# In[2]:


#откроем одну из таблиц
data = pd.read_excel('/Users/angelinakotelnikova/Desktop/пет проекты/Медицина/2021_Таблица_009_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx')
data.head(7)


# In[3]:


#откроем таблицу с 4го уровня заголовков, чтобы нагляднее было информация о таблице
data=pd.read_excel('/Users/angelinakotelnikova/Desktop/пет проекты/Медицина/2021_Таблица_009_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx', 
                header=[4])
data.info()


# Для того чтобы таблица корректно открылась, необходимо избавиться от лишних заголовков, удалить ненужные колонки и вытащить из ячеек три показателя разделенных символами "\n". После начиная с 5 колонки нужно заменить тип данных у ряда колонок с object на float, в числах вместо точки стоит запятая, в связи с чем это воспринимается как строка.
# 
# Предварительно была  проверка данных и значения из общей таблицы не совпадали с двумя присущими ей таблицами разделенными на пол больных. Так же сумма значений отмеченных как "всего" не совпала со значениями разделенными по тем или иным признакам. 
# 
# Заказчик сказал, что мы можем доверять данным, которые находятся в двух таблицах разделенных по полу. Так же вместе с заказчиком было решено избавить от всех строк и колонок "всего". 
# 
# Дальнейшая работа пойдёт только с таблицами разделенными по полу. 
# 

# ## Функции
# 
# Так как все таблицы одинаковые по структуре, я написала ряд функций для быстрой обработки таблиц. 
# 
# Функция open_table открывает таблицу в формате excel начиная с 4го уровня заголовков, удаляя лишние  сформировавшиеся колонки. Функция сразу переименовывает название колонок в соответствие с оригинальной таблицей excel. И так же удаляет колонку и строку со значениями "всего". 

# In[4]:


def open_table(link):
    #откроем excel файл
    df = pd.read_excel(link, header=[4])
    
    #удалим лишние колонки
    df = df.drop(['Unnamed: 1', 'Unnamed: 5'], axis=1)

    #меняем название колонкам в соответствие с таблицей в excel
    df = df.rename(columns={'Unnamed: 0':'Нозологическая_форма', 'Unnamed: 2':'Код_МКБ_10', 
                                      'Unnamed: 3':'Станд_показатель', 'Unnamed: 4':'Ошиб_станд_показателя'})
    #удалим колонку всего
    df = df.drop('Всего', axis=1)
    #удалим строку "Злокачественные новообразования - всего"
    df = df.drop(index=0)

    return df


# Заказчик хотел отразить все показатели находящиеся в таблице. Из-за особенностей расположения данных это было сложно сделать корректно. Поэтому я решила из двух таблиц создать четыре, в двух таблицах будут показатели: абсолютное число, грубый показатель и удельный вес. В двух остальных - стандартный показатель. В дальнейшем я объединю одинаковые таблицы присущие разным полам.  
# 
# Функция stand_indicator  сформирует таблицу со стандартным показателем. Оставляет колонки, которые присущи только к стандартному показателю. Создает новые колонки для дальнейшего объединения с другой таблицей. 

# In[5]:


def stand_indicator(data_1, data_2, name_2):

    def cols(df, name): 
    
        df = df.iloc[:, :4]     #оставляем только первые четыре колонки
        #создим новые колонки пол статус, чтобы в дальнейшем объединить две таблицы
        df['пол'] = name   
        df['статус'] = name_2
        df.insert(2, 'пол', df.pop('пол')) #поменяем индексы колонок
        df.insert(3, 'статус', df.pop('статус')) #поменяем индексы колонок
    
        return df
    #создадим новые колонки, определяющие пол больных
    data_1 = cols(data_1, 'мужчина')
    data_2 = cols(data_2, 'женщина')
    
    unity = pd.concat([data_1, data_2], sort=False, axis=0)
    
    return unity


# Функция split_col с помощью метода melt преобразует таблицу из широкой в длинную, вытаскивая возраст больных. Дальше из ячеек с тремя значениями вытаскивает их и присваивает соответствующие показатели (такие же, как в оригинальной таблице excel). Создает новые колонки для дальнейшего объединения с другой таблицей. 

# In[6]:


def split_col(data, name, name_2):  #data - таблица, name - пол, name_2 - заболеваемость или смертность
    
    #с помощью melt преобразуем возраст респондентов в "длинный" формат
    data = pd.melt(data, ["Нозологическая_форма", 'Код_МКБ_10', 'Станд_показатель', 'Ошиб_станд_показателя'], 
                   var_name="возраст", value_name="count") 
    #data = data.sort_values(by=["Нозологическая_форма"])
    
    #из всех колонок, в которых в одной ячейке находится три показателя, вытащим их и сохраним в новых колонках 
    cols = data.columns[5:].to_list() #список колонок, в которых в одной ячейке находится три показателя     
       
    for x in cols:
        new_df = data[x].str.split("\n", expand=True)                            #разделение колонок на три новые по символу \n
        new_df = new_df.rename(columns={i:f"{i}_{x}" for i in new_df.columns})   #все новые столбцы переименовываются с использованием их оригинального имени, добавляя индексы
        data = pd.concat([data, new_df], axis=1).drop(columns=[x])               #новые столбцы добавляются к оригинальному DataFrame, а исходный столбец удаляется
        
    #переименуем колонки
    data = data.rename(columns={'0_count':'Абс_число', '1_count':'Грубый', '2_count':'Уд_вес'})
    
    #переводим все заглавные буквы в наименовании колонок в нижний регистр
    data.columns = [x.lower() for x in data.columns]
    
    #создим новые колонки пол статус, чтобы в дальнейшем объединить две таблицы
    data['пол'] = name
    data['статус'] = name_2
    
    #поменяем индексы колонок 
    data.insert(2, 'пол', data.pop('пол'))
    data.insert(3, 'возраст', data.pop('возраст'))
    data.insert(4, 'статус', data.pop('статус'))
    
    return data


# Функция change_type меняет запятые на точки и преобразует тип данных в float. 

# In[7]:


def change_type(data):
    new_cols = data.columns[5:].to_list() #список колонок, у которых необходимо поменять тип данных
    
    for i in new_cols:
        data[i] = data[i].replace(',', '.', regex=True)  #заменяем запятые на точки
        data[i] = data[i].astype(float)  #меняем тип данных на float
    
    return data


# Функция для сохранения таблиц в CSV формат.

# In[8]:


#для сохранения таблиц в CSV формате, file_path - путь куда сохраняем таблицу
def safe_file(file_path, data):
    # Сохраните DataFrame в формате CSV
    data.to_csv(file_path, index=False)


# ## Таблицы заболеваемости. 
# 
# В данном разделе  проведена работа по изучению и обработке таблиц "Заболеваемость различных возрастно-половых групп населения злокачественными новообразованиями". 
# 
# Откроем две таблицы с разным полом больных через функцию open_table.

# In[9]:


#через функцию открываем таблицы
morbidity_man, morbidity_woman = open_table('/Users/angelinakotelnikova/Desktop/пет проекты/Медицина/2021_Таблица_010_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx'),\
open_table('/Users/angelinakotelnikova/Desktop/пет проекты/Медицина/2021_Таблица_011_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx')

for i in [morbidity_man, morbidity_woman]:
    display(i.head())


# In[10]:


#изучим типы данных, посмотрим кол-во строк у таблиц
for i in [morbidity_man, morbidity_woman]:
    display(i.info())


# В данных нет пропусков. 
# 
# Сформируем таблицы только со стандартным показателем, удалив колонки с возрастом через функцию stand_indicator. И затем объединим таблицы с разным полом.

# In[11]:


#создаем датафреймы для создания таблицы только со станд. показателем 
morbidity_m = morbidity_man.copy(deep=True)
morbidity_w = morbidity_woman.copy(deep=True)

#применим функцию stand_indicator
morbidity_stand_indicator = stand_indicator(morbidity_m, morbidity_w, 'заболеваемость')
display(morbidity_stand_indicator.sample(5))
morbidity_stand_indicator.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют все  колонки.  
# 
# Сформируем таблицы с показателями: абсолютное число, грубый показатель и удельный вес через функцию split_col.

# In[12]:


morbidity_man = split_col(morbidity_man, 'мужчина', 'заболеваемость')
morbidity_woman = split_col(morbidity_woman, 'женщина', 'заболеваемость')

display(morbidity_man.head(3))
display(morbidity_woman.head(3))

#изучим типы данных, посмотрим кол-во строк у таблиц
for i in [morbidity_man, morbidity_woman]:
    display(i.info())


# Пропусков нет. Колонки соответствуют тому результату, который был задуман. 
# 
# Объединим таблицы morbidity_man и morbidity_woman с помощью concat. 

# In[13]:


#объединим таблицы morbidity_man и morbidity_woman
unity_morbidity = pd.concat([morbidity_man, morbidity_woman], sort=False, axis=0)

display(unity_morbidity.sample(5))
unity_morbidity.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют необходимые колонки. 
# 
# Поменяем тип данных на float через функцию change_type.

# In[14]:


#поменяем тип данных
unity_morbidity = change_type(unity_morbidity)
unity_morbidity.info()


# Посмотрим результат объединенной таблицы. 

# In[15]:


unity_morbidity.sample(5)


# ## Таблицы смертности.
# 
# В данном разделе проведена работа по изучению и обработке таблиц "Смертности различных возрастно-половых групп населения от злокачественных новообразований".
# 
# Откроем две таблицы с разным полом умерших через функцию open_table.

# In[16]:


mortality_m, mortality_w = open_table('/Users/angelinakotelnikova/Desktop/пет проекты/медицина/2021_Таблица_067_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx'),\
open_table('/Users/angelinakotelnikova/Desktop/пет проекты/медицина/2021_Таблица_068_Злокачественные_новообразования_в_РФ_(заболеваемость_и_смертность).xlsx')

for i in [mortality_m, mortality_w]:
    display(i.head())


# In[17]:


#изучим типы данных, посмотрим кол-во строк у таблиц
for i in [mortality_m, mortality_w]:
    display(i.info())


# В данных нет пропусков. 
# 
# Сформируем таблицы только со стандартным показателем, удалив колонки с возрастом через функцию stand_indicator. И затем объединим таблицы с разным полом.

# In[18]:


#создаем датафреймы для создания таблицы только со станд показателем 
mortality_man = mortality_m.copy(deep=True)
mortality_woman = mortality_w.copy(deep=True)

#применим функцию
mortality_stand_indicator = stand_indicator(mortality_man, mortality_woman, 'смертность')
#Выведем результат
display(mortality_stand_indicator.sample(7))
mortality_stand_indicator.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют все колонки.  
# 
# Сформируем таблицы с показателями: абсолютное число, грубый показатель и удельный вес через функцию split_col.

# In[19]:


#применим функцию
mortality_m = split_col(mortality_m, 'мужчина', 'смертность')
mortality_w = split_col(mortality_w, 'женщина', 'смертность')

#откроем таблицы
display(mortality_m.head(3))
display(mortality_w.head(3))

#изучим типы данных, посмотрим кол-во строк у таблиц
for i in [mortality_m, mortality_w]:
    display(i.info())


# Пропусков нет. Колонки соответствуют тому результату, который был задуман. 
# 
# Объединим таблицы mortality_m и mortality_w с помощью concat.

# In[20]:


#объединим таблицы morbidity_man и morbidity_woman
mortality = pd.concat([mortality_m, mortality_w], sort=False, axis=0)

#Выведем результат
display(mortality.sample(5))
mortality.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют необходимые колонки. 
# 
# Поменяем тип данных на float через функцию change_type.

# In[21]:


#поменяем тип данных
mortality = change_type(mortality)
mortality.info()


# Посмотрим результат объединенной таблицы.

# In[22]:


mortality.sample(10)


# ## Формирование общих таблиц
# 
# В данном разделе сформируем две общие таблицы разделенные на вид показателей. 
# 
# Объединим таблицы с показателями: абсолютное число, грубый показатель и удельный вес.

# In[23]:


#объединим таблицы morbidity_man и morbidity_woman
unity = pd.concat([unity_morbidity, mortality], sort=False, axis=0)
#Выведим результат
display(unity.sample(5))
unity.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют необходимые колонки. 
# 
# Далее сохраним таблицу в CSV формате для DataLens.

# In[27]:


# #Сохраним таблицу 
# safe_file('/путь/unity.csv', 
#           unity)


# Объединим таблицы с показателями со стандартным показателем.

# In[25]:


#объединим таблицы morbidity_man и morbidity_woman
unity_stand_indicator = pd.concat([morbidity_stand_indicator, mortality_stand_indicator], sort=False, axis=0)
#Выведим результат
display(unity_stand_indicator.sample(5))
unity_stand_indicator.info()


# Объединение произошло успешно, пропусков не появилось, строки соответствуют действительности и присутствуют необходимые колонки. 
# 
# Далее сохраним таблицу в CSV формате для DataLens.

# In[28]:


# #Сохраним таблицу 
# safe_file('путь/unity_stand_indicator.csv', 
#           unity_stand_indicator)

